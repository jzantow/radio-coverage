<!DOCTYPE html>
<html>
<head>
  <title>Radio Coverage Map</title>
  <meta charset="utf-8" />
  <style>
    html, body, #map {
      height: 100%;
      margin: 0;
      padding: 0;
    }
  </style>

  <!-- Include geometry library so we can measure distances -->
  <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDlgV94Xs1mTP01IZo3wqQWpx9png3l4DE&libraries=geometry"></script>
</head>
<body>
  <div id="map" style="width:100%; height:100vh;"></div>

  <script>
    let map;
    const storeMarkers   = [];
    const stationMarkers = [];
    const stationCircles = [];
    const stationData    = [];

    function initMap() {
      map = new google.maps.Map(document.getElementById("map"), {
        zoom: 5,
        center: { lat: 39.5, lng: -98.35 },
      });

      // Two InfoWindows: one for stores, one for stations
      const storeInfoWindow   = new google.maps.InfoWindow();
      const stationInfoWindow = new google.maps.InfoWindow();

      fetch('https://jzantow.github.io/radio-coverage/locations.json')
        .then(res => res.json())
        .then(locations => {
          locations.forEach((loc, i) => {
            // 1) DEBUG: print out each location’s Type
            console.log(`LOADED [${i}]: Name="${loc.Name}", Type="${loc.Type}"`);

            const position = { lat: loc.Latitude, lng: loc.Longitude };
            const color = (loc.Type === "Station") ? "#1E90FF" : "#FF6347";

            // 2) Create the circle for stations—make it non-clickable so it won't intercept clicks
            const circle = new google.maps.Circle({
              strokeColor: color,
              strokeOpacity: 0.8,
              strokeWeight: 2,
              fillColor: color,
              fillOpacity: 0.25,
              map: (loc.Type === "Station") ? map : null,
              center: position,
              radius: (loc.Radius || 0) * 1609.34,
              clickable: false
            });

            // 3) Create a marker for both Stores and Stations
            const marker = new google.maps.Marker({
              position,
              map,
              title: loc.Name,
              icon: {
                path: google.maps.SymbolPath.CIRCLE,
                scale: 7,
                fillColor: color,
                fillOpacity: 1,
                strokeWeight: 1,
                strokeColor: "#fff"
              }
            });

            if (loc.Type === "Store") {
              // ─── STORE ───
              storeMarkers.push(marker);

              // STORE: hover → show “In Range Of”
              marker.addListener("mouseover", () => {
                console.log("STORE HOVER →", loc.Name);

                const stationsInRange = stationCircles
                  .map((c, idx) => {
                    const d = google.maps.geometry.spherical.computeDistanceBetween(
                      new google.maps.LatLng(loc.Latitude, loc.Longitude),
                      c.getCenter()
                    );
                    if (d <= c.getRadius()) {
                      return stationData[idx]?.Name || null;
                    }
                    return null;
                  })
                  .filter(Boolean);

                const hoverHTML = `
                  <strong>${loc.Name}</strong><br>
                  <b>In Range Of:</b><br>
                  ${stationsInRange.length ? stationsInRange.join("<br>") : "None"}
                `;
                storeInfoWindow.setContent(hoverHTML);
                storeInfoWindow.open(map, marker);
              });

              marker.addListener("mouseout", () => {
                storeInfoWindow.close();
              });

              // STORE: click → filter bubbles & show InfoWindow
              marker.addListener("click", () => {
                console.log("STORE CLICK →", loc.Name);

                // 1) find which stations are in range
                const inRangeIndices = [];
                stationCircles.forEach((c, idx) => {
                  const d = google.maps.geometry.spherical.computeDistanceBetween(
                    new google.maps.LatLng(loc.Latitude, loc.Longitude),
                    c.getCenter()
                  );
                  if (d <= c.getRadius()) {
                    inRangeIndices.push(idx);
                  }
                });

                // 2) show only those station markers/circles that are inRange; hide the rest
                stationMarkers.forEach((m, idx) => {
                  if (inRangeIndices.includes(idx)) {
                    m.setMap(map);
                    stationCircles[idx].setMap(map);
                  } else {
                    m.setMap(null);
                    stationCircles[idx].setMap(null);
                  }
                });

                // 3) build InfoWindow content listing stations in range
                const listedNames = inRangeIndices
                  .map(i => stationData[i]?.Name || "")
                  .filter(name => name);

                const infoHTML = `
                  <strong>${loc.Name}</strong><br>
                  <b>Stations In Range:</b><br>
                  ${listedNames.length ? listedNames.join("<br>") : "None"}
                `;
                storeInfoWindow.setContent(infoHTML);
                storeInfoWindow.open(map, marker);
              });

            } else if (loc.Type === "Station") {
              // ─── STATION ───
              stationData.push(loc);
              stationMarkers.push(marker);
              stationCircles.push(circle);

              // STATION: click → just pop up its name
              marker.addListener("click", () => {
                console.log("STATION CLICK →", loc.Name);
                stationInfoWindow.setContent(`<strong>${loc.Name}</strong>`);
                stationInfoWindow.open(map, marker);
              });
            }
          });
        })
        .catch(err => {
          console.error("Failed to load locations.json:", err);
          alert("Could not load location data. Check console for details.");
        });
    }

    window.onload = initMap;
  </script>
</body>
</html>
